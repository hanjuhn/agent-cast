{
  "workspace_info": {
    "workspace_id": "253d3416051880f08e42e3fa147fc37c",
    "workspace_name": "BTM_25Q3_GEN의 워크스페이스",
    "workspace_icon": "🤖",
    "workspace_description": "노션 통합 워크스페이스",
    "member_count": 1,
    "plan": "Unknown",
    "created": "Unknown"
  },
  "databases": [
    {
      "id": "253d3416-0518-80f0-8e42-e3fa147fc37c",
      "title": "Naver Cloud AI DevDay",
      "description": "",
      "last_edited": "2025-08-18T08:00:00.000Z",
      "created": "2025-08-18T05:16:00.000Z",
      "url": "https://www.notion.so/253d3416051880f08e42e3fa147fc37c",
      "properties": {
        "생성일": "created_time",
        "태그": "multi_select",
        "이름": "title"
      },
      "entries": [
        {
          "id": "253d3416-0518-806a-9ddb-f4fb4be353a9",
          "title": "지금 주목할 LLM 기술 흐름과 생성형 AI 적용 인사이트 (네이버클라우드 강지나 수석) (1)",
          "last_edited": "2025-08-18T08:00:00.000Z",
          "created": "2025-08-18T06:08:00.000Z",
          "url": "https://www.notion.so/LLM-AI-1-253d34160518806a9ddbf4fb4be353a9",
          "properties": {
            "생성일": "2025-08-18T06:08:00.000Z",
            "태그": [],
            "이름": "지금 주목할 LLM 기술 흐름과 생성형 AI 적용 인사이트 (네이버클라우드 강지나 수석) (1)"
          }
        },
        {
          "id": "253d3416-0518-8062-97fd-ea06d0674f22",
          "title": "AI Agent 구현을 위한 MCP 활용 방안 (네이버클라우드 최장호 수석) (1)",
          "last_edited": "2025-08-18T08:00:00.000Z",
          "created": "2025-08-18T06:08:00.000Z",
          "url": "https://www.notion.so/AI-Agent-MCP-1-253d34160518806297fdea06d0674f22",
          "properties": {
            "생성일": "2025-08-18T06:08:00.000Z",
            "태그": [],
            "이름": "AI Agent 구현을 위한 MCP 활용 방안 (네이버클라우드 최장호 수석) (1)"
          }
        },
        {
          "id": "253d3416-0518-8067-b800-f6b577ec70ab",
          "title": "Multi-AI Agent 아키텍처와 구현 전략 (네이버클라우드 허창현 리더) (1)",
          "last_edited": "2025-08-18T08:00:00.000Z",
          "created": "2025-08-18T06:07:00.000Z",
          "url": "https://www.notion.so/Multi-AI-Agent-1-253d341605188067b800f6b577ec70ab",
          "properties": {
            "생성일": "2025-08-18T06:07:00.000Z",
            "태그": [],
            "이름": "Multi-AI Agent 아키텍처와 구현 전략 (네이버클라우드 허창현 리더) (1)"
          }
        }
      ]
    }
  ],
  "pages": [
    {
      "id": "253d3416-0518-8062-97fd-ea06d0674f22",
      "title": "AI Agent 구현을 위한 MCP 활용 방안 (네이버클라우드 최장호 수석) (1)",
      "last_edited": "2025-08-18T08:00:00.000Z",
      "created": "2025-08-18T06:08:00.000Z",
      "url": "https://www.notion.so/AI-Agent-MCP-1-253d34160518806297fdea06d0674f22",
      "content": [
        {
          "type": "paragraph",
          "text": "앞선 발표에서 소개하였듯, AI 에이전트를 실제 서비스에 적용하기 위해선 LLM이 다양한 툴과 연동되어야 합니다. 하지만 이 연동 과정이 생각보다 만만치 않죠. 저는 이번 세션에서 MCP가 왜 필요한지, 어떻게 구현되고 적용되는지 사례를 중심으로 공유드리겠습니다."
        },
        {
          "type": "heading_2",
          "text": "AI 에이전트는 어떻게 진화하고 있을까?"
        },
        {
          "type": "paragraph",
          "text": "초기 LLM은 단순 질문에 답하거나 문장을 생성하는 수준이었습니다. 그러나 학습된 시점까지의 데이터로 답변을 해주기 때문에, 내부 데이터 혹은 최신 데이터를 실시간으로 반영할 수 있도록 RAG(Retrieval-Augmented Generation) 방식이 등장했고, 지금은 LLM이 외부 툴과 연동되는 에이전트 형태로 발전하고 있습니다."
        },
        {
          "type": "paragraph",
          "text": "에이전트는 사용자의 요청을 받고, 이를 처리하기 위해 어떤 툴을 써야 할지 판단하고, 툴을 호출하고 실행한 뒤, 결과를 바탕으로 답변을 구성하는 순서. 'Observe(관찰) → Plan(계획) → Act(실행)' 구조로 움직이게 되는데요. 이때 핵심은 어떤 툴을 얼마나 잘 연결할 수 있느냐, 그리고 툴 호출을 잘 수행할 수 있는 LLM을 쓰느냐에 달려 있어요. 그리고 MCP는 이 부분에서 도움을 줄 수 있는 것이죠."
        },
        {
          "type": "image",
          "text": "에이전트의 작동 구조 (출처: https://www.bcg.com/capabilities/artificial-intelligence/ai-agents)"
        },
        {
          "type": "heading_2",
          "text": "MCP가 등장한 이유"
        },
        {
          "type": "paragraph",
          "text": "문제는 툴을 연결하는 과정이 매우 번거롭다는 점입니다. 예를 들어 LLM 기반 애플리케이션(LangChain, ChatGPT, Claude 등)에 메일, Notion, GitHub, Slack 같은 도구를 연동하려면 각각의 SDK나 API에 맞춰 따로 개발해야 하죠."
        },
        {
          "type": "image",
          "text": "MCP의 등장 배경: 여러 도구를 연결하는 과정의 번거로움"
        },
        {
          "type": "paragraph",
          "text": "이런 문제를 해결하기 위해 등장한 것이 바로 MCP(Multi-Tool Connection Protocol)입니다. 엔트로픽(Anthropic)에서 제안한 방식인데, 요약하자면 \"LLM이 외부 툴과 통신할 수 있도록 표준화된 프로토콜\"이라고 할 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "LLM(예: HyperCLOVA X, Claude, GPT 등)은 MCP 클라이언트, 외부 툴(예: Notion, Gmail, GitHub 등)은 MCP 서버, 둘 사이를 표준화된 방식(JSON-RPC 기반)으로 통신하게 합니다. 이 프로토콜 덕분에 여러 툴을 붙일 때 매번 복잡한 로직을 새로 짤 필요 없이 간단히 표준만 맞춰주면 바로 쓸 수 있게 되는 거죠."
        },
        {
          "type": "image",
          "text": "MCP: LLM이 외부 데이터 및 도구와 상호작용할 수 있도록 설계된 프로토콜 (이미지 출처)"
        },
        {
          "type": "heading_2",
          "text": "MCP, 이렇게 쓸 수 있어요."
        },
        {
          "type": "paragraph",
          "text": "저희도 MCP를 기반으로 다양한 프로젝트를 진행하고 있습니다. 제가 직접 해본 예로, 긴 유튜브 영상을 요약해 노션에 자동 정리하는 워크플로우를 MCP로 만들었습니다. 자막 추출, 댓글 요약, 캡처 생성, 노션 업로드까지 한 줄 지시로 Claude가 다 처리해 주니 정말 AI 에이전트 같더라고요."
        },
        {
          "type": "paragraph",
          "text": "코드 관리에도 MCP는 굉장히 유용하게 쓰입니다. GitHub 이슈를 자동으로 읽고, 관련 코드를 수정하고, 커밋까지 해주는 자동화도 가능합니다. 실제로 Cursor AI에서 이런 기능을 통해 이슈를 해결하는 시나리오를 구성해 봤고요."
        },
        {
          "type": "heading_2",
          "text": "반복 없이 챗봇 확장하기: MCP로 유연하게 구성하는 방법"
        },
        {
          "type": "paragraph",
          "text": "고객사에서 자주 요청하는 기능 중 하나가 '챗봇에 실시간 웹 검색이나 내부 문서 검색 기능을 붙이는 것'입니다. 하지만 이를 구현하려면 매번 새로운 API를 붙이고 복잡한 로직을 짜야 해서 부담이 크죠. 이런 상황에서 MCP를 사용하면 도구 추가나 교체가 표준화된 방식으로 가능해 훨씬 유연하게 구성할 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "예를 들어 LangGraph로 에이전트의 흐름을 만들고, 내부에서 MCP Client가 동작해 외부 MCP Server(웹 검색, 문서 검색 등)와 통신하는 구조를 생각해 볼 수 있습니다."
        },
        {
          "type": "image",
          "text": "MCP Client와 MCP Server간 통신 구조"
        },
        {
          "type": "paragraph",
          "text": "이 구조는 네이버 클라우드 플랫폼 환경에서도 쉽게 구성할 수 있어요. 예를 들어, LLM은 네이버클라우드의 HyperCLOVA X를 사용하고, 벡터 DB는 NAVER Search DB 혹은 Pinecone 등을 활용합니다. 서버는 Docker(도커)로 로컬에 구성하면 보안상 더 안전하고요."
        },
        {
          "type": "paragraph",
          "text": "실제로 오래된 문서 정보를 최신 웹 데이터와 비교해 더 정확한 답을 자동으로 판단하는 AI 에이전트를 구현해 봤습니다. “예결위 위원이 몇 명이야?”라는 질문에 문서와 웹 정보를 비교해 최신 값을 반환하는 방식인데요. 이런 구조 덕분에 고객사는 복잡한 정보 판단까지 자동화할 수 있습니다."
        },
        {
          "type": "image",
          "text": "네이버 클라우드 플랫폼을 활용한 MCP 구성"
        },
        {
          "type": "heading_2",
          "text": "MCP, 선택이 아닌 필수"
        },
        {
          "type": "paragraph",
          "text": "결국 에이전트는 ‘연결’이 핵심입니다. MCP는 툴을 만드는 개발자와, 그것을 활용할 수 있는 LLM 사이의 연결 고리를 제공합니다. 앞으로 Agentic AI가 더 발전하려면, 다양한 툴과의 연동이 점점 더 중요해질 겁니다. MCP 같은 표준이 자리 잡을수록 개발자는 더 빠르게 툴을 만들고, LLM은 더 강력한 에이전트로 진화할 수 있겠죠."
        },
        {
          "type": "paragraph",
          "text": "여기 계신 여러분도 AI 프로젝트를 하시면서 반복적인 툴 연결 작업이 부담스럽다고 느끼셨다면, MCP 도입을 꼭 고려해 보시길 추천드립니다."
        }
      ]
    },
    {
      "id": "253d3416-0518-8067-b800-f6b577ec70ab",
      "title": "Multi-AI Agent 아키텍처와 구현 전략 (네이버클라우드 허창현 리더) (1)",
      "last_edited": "2025-08-18T08:00:00.000Z",
      "created": "2025-08-18T06:07:00.000Z",
      "url": "https://www.notion.so/Multi-AI-Agent-1-253d341605188067b800f6b577ec70ab",
      "content": [
        {
          "type": "paragraph",
          "text": "많은 분들이 멀티 에이전트 시스템이라고 하면 굉장히 복잡하고 먼 이야기로 느끼시곤 합니다. 하지만 사실 우리가 AI 질문을 던지는 그 단순한 행동도 하나의 에이전트를 작동시키는 행위입니다."
        },
        {
          "type": "paragraph",
          "text": "요즘은 다양한 AI 도구들이 목적에 따라 다양하게 활용되고 있죠. 이렇게 상황에 따라 유연하게 AI를 사용하는 것 자체가 이미 ‘에이전트적 행동’입니다. 저는 이런 개별 AI들이 서로 협력해서 목표를 달성해 나가는 방식, 즉 멀티 AI 에이전트의 개념과 구현 방식에 대해 말씀드리고자 합니다."
        },
        {
          "type": "heading_2",
          "text": "멀티 에이전트가 왜 필요할까요?"
        },
        {
          "type": "paragraph",
          "text": "단일 에이전트만으로는 복잡한 작업을 완벽하게 수행하기 어렵습니다. 예를 들어, 자연어로 SQL 쿼리를 생성하는 NL2SQL(Natural Language to SQL) 작업에서는 환각(Hallucination) 현상이나 정확도 문제가 자주 발생합니다."
        },
        {
          "type": "paragraph",
          "text": "이러한 한계를 극복하기 위해서는 역할이 나뉜 여러 에이전트들이 단계적으로 협업 할 수 있어야 합니다. 예를 들어, NL2SQL에서는 키워드 추출 에이전트, SQL 표준 준수 검증 에이전트, 쿼리 동작 검증 에이전트 등 여러 특화된 에이전트가 단계적으로 작업을 수행하는 그림이죠."
        },
        {
          "type": "paragraph",
          "text": "실제 적용한 사례를 하나 소개하자면 '로그 패턴 분석 기반 위협 탐지 시스템'이 있습니다. 이 시스템에는 특정 로그 패턴을 감지하는 모델, 감지된 오류 유형을 분석하는 모델, 사용자에게 적절한 후속 조치를 안내하는 모델이 하나의 팀처럼 협업하면서 더 신속하고 정확한 결과를 제공 하게 되죠."
        },
        {
          "type": "heading_2",
          "text": "멀티 에이전트 구현 프레임워크"
        },
        {
          "type": "paragraph",
          "text": "이런 시스템을 실제로 구현하려면 도구가 필요하겠죠. 제가 많이 써보고 추천드릴 수 있는 프레임워크는 다음과 같습니다:"
        },
        {
          "type": "bulleted_list_item",
          "text": "LangGraph: 그래프 형태로 노드(에이전트)와 엣지(조건)를 구성해 절차적 작업 흐름을 구현할 때 좋습니다."
        },
        {
          "type": "bulleted_list_item",
          "text": "AutoGen: 여러 에이전트가 서로 대화하면서 합의를 도출하는 데 적합합니다. 로그 분석이나 토론 기반 작업에 유용합니다."
        },
        {
          "type": "bulleted_list_item",
          "text": "CrewAI: 역할 기반 에이전트 설계에 초점을 맞추고 있어, 팀 단위 구조를 구성할 때 활용하기 좋습니다."
        },
        {
          "type": "bulleted_list_item",
          "text": "OpenAI Agent SDK, Google ADK 등도 상용 환경에서 강력하게 사용할 수 있는 도구입니다."
        },
        {
          "type": "paragraph",
          "text": "저는 목적과 업무 성격에 따라 프레임워크를 조합해서 유연하게 사용하는 것이 매우 중요하다고 생각합니다."
        },
        {
          "type": "heading_2",
          "text": "멀티 에이전트 아키텍처 구성 방법"
        },
        {
          "type": "paragraph",
          "text": "대표적인 아키텍처 패턴 두 가지를 소개해 드리겠습니다."
        },
        {
          "type": "paragraph",
          "text": "1. 네트워크 패턴 (Swarm Pattern)"
        },
        {
          "type": "paragraph",
          "text": "이 방식은 중앙 통제자 없이, 여러 에이전트가 서로 ‘툴콜링’과 ‘핸드오프’를 통해 유기적으로 작업을 이어가는 구조입니다. 예를 들어, 과학 정보를 검색하는 에이전트가 번역 에이전트에게 결과를 넘기고, 다시 사용자에게 제공하는 흐름이죠."
        },
        {
          "type": "paragraph",
          "text": "2. 슈퍼바이저 패턴 (Supervisor Pattern)"
        },
        {
          "type": "paragraph",
          "text": "이건 계층 구조를 기반으로 한 방식입니다. 중앙의 슈퍼바이저가 여러 하위 에이전트에게 역할을 분담하고, 결과를 검토하고, 필요하면 다시 지시하는 구조입니다. 예를 들어, 한 팀은 자료를 수집하고, 다른 팀은 보고서를 작성하는 구조를 생각해 보시면 이해가 쉬울 겁니다. 벤치마크 결과를 봐도 복잡한 작업에서는 단일 에이전트보다 이런 협업 기반 구조가 성능 면에서 훨씬 효율적입니다. 지연 시간도 줄고, 토큰 소모량도 적습니다."
        },
        {
          "type": "heading_2",
          "text": "멀티 에이전트 아키텍처를 설계할 때 고려해야 할 것들"
        },
        {
          "type": "paragraph",
          "text": "멀티 에이전트를 실제로 구축하다 보면 몇 가지 실무적인 고민이 생깁니다."
        },
        {
          "type": "paragraph",
          "text": "첫째, '에이전트의 상태와 대화 기록을 어떻게 관리할 것인가'입니다. 이게 잘 되어야 유지 보수나 디버깅이 쉬워집니다. 저는 LangGraph나 AutoGen에서 제공하는 단계별 로깅 기능을 활용하고, MLFlow 같은 MLOps 툴과 연계해서 트래킹을 자동화하고 있습니다."
        },
        {
          "type": "paragraph",
          "text": "둘째, '에이전트를 역할 단위로 잘게 나눠서 설계하는 것'이 중요합니다. 마이크로 서비스 아키텍처처럼, 작은 단위로 쪼개면 GPU 자원도 효율적으로 쓰고, 모델 핸들링도 쉬워집니다. 하지만 너무 작게 나누면 오히려 관리가 복잡해지기 때문에, 적절한 균형을 찾는 것이 핵심입니다."
        },
        {
          "type": "image",
          "text": "멀티 에이전트 아키텍처 설계에 참고할 수 있는 Framework"
        },
        {
          "type": "heading_2",
          "text": "AI 기술자가 갖춰야 할 역량은?"
        },
        {
          "type": "paragraph",
          "text": "멀티 에이전트를 설계하고 운영하기 위해서는 도구도 중요하지만, 결국 사람의 역량이 핵심입니다. 제가 특히 강조 드리고 싶은 건 두 가지입니다."
        },
        {
          "type": "paragraph",
          "text": "첫째, 모델에 대한 깊은 이해입니다. HyperCLOVA X 같은 대형 모델이 어떻게 작동하는지 알고, 직접 SFT(Supervised Fine-Tuning) 등으로 튜닝해 보는 경험이 필요합니다."
        },
        {
          "type": "paragraph",
          "text": "둘째, 프레임워크를 활용하는 실전 능력입니다. LangGraph, AutoGen 같은 오픈소스부터 상용 SDK까지 다양한 툴을 목적에 맞게 조합하고, 적재적소에 쓸 수 있는 역량이 점점 더 중요해지고 있습니다."
        },
        {
          "type": "image",
          "text": "프레임워크 실전 활용을 위해 알아두면 좋은 내용들"
        },
        {
          "type": "paragraph",
          "text": "멀티 에이전트 시스템은 결코 먼 미래의 기술이 아닙니다. 우리는 이미 다양한 AI와 함께 일하고 있고, 이 AI들을 어떻게 조직적으로 묶고 활용하느냐에 따라 서비스 품질도, 업무의 효율도, 기업의 경쟁력도 달라질 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "이제는 단일 모델을 넘어, 협업하는 AI의 시대가 열리고 있는 만큼, 여러분의 서비스에도 멀티 에이전트를 어떻게 접목할 수 있을지, 오늘 이 시간을 계기로 꼭 고민해 보셨으면 합니다."
        },
        {
          "type": "heading_2",
          "text": "사전 질문"
        },
        {
          "type": "paragraph",
          "text": "Q1. 각 Agent의 상태(State)와 Agent 간의 대화 기록(History)을 관리하는 것은 디버깅과 유지보수의 핵심입니다. 수십 개의 Agent가 상호작용하는 복잡한 시스템에서, 분산된 상태 정보를 효과적으로 추적하고 관리하기 위한 모범 사례나 아키텍처 전략이 있다면 무엇일까요?"
        },
        {
          "type": "paragraph",
          "text": "현재 다양한 프레임워크들이 등장하고 있으며, 디버깅과 로깅 체계의 사전 구축은 멀티 에이전트 시스템 구현에 있어 매우 중요한 요소입니다."
        },
        {
          "type": "paragraph",
          "text": "예를 들어, LangGraph는 각 노드의 실행 상태를 스트리밍 방식으로 모니터링할 수 있는 기능을 제공하고 있으며, AutoGen 또한 실행 시간 중 발생하는 로그를 관리할 수 있는 패키지를 지원합니다."
        },
        {
          "type": "paragraph",
          "text": "이외에도 여러 커뮤니티 기반 프로젝트들이 활발히 진행 중이며, 예를 들어 AutoGen ContextPlus와 같은 도구를 활용하면 상태 관리 및 로그 추적에 도움이 될 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "또한 최근에는 MLflow가 멀티 에이전트 워크플로우에 맞춘 로깅 모듈 업데이트를 지속적으로 제공하고 있어, 이러한 툴을 활용한 실행 이력 관리와 성능 분석도 적극적으로 고려해볼 만합니다."
        },
        {
          "type": "paragraph",
          "text": "Q2. 실무에 A2A를 적용하는 게 실제로 다른 아키텍처 선택지보다 뛰어날까요?\n에이전트를 구분하는 단위를 설정하는 게 중요할 것 같은데, 어려움은 없으셨나요?"
        },
        {
          "type": "paragraph",
          "text": "A2A 아키텍처는 분명한 장점과 함께 실질적인 도전 과제도 존재합니다.\n에이전트를 너무 세분화하면 시스템 복잡도가 높아지고, 반대로 지나치게 포괄적으로 구성하면 오버헤드가 증가하며 에이전트 설계의 본래 취지가 희석될 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "따라서 기능 단위가 아닌, 핵심 의사결정 단위를 기준으로 에이전트를 설계하는 것이 보다 효과적입니다."
        },
        {
          "type": "paragraph",
          "text": "에이전트를 설계할 때는 다양한 기능을 하나의 에이전트에 통합할 수 있는지 먼저 판단하고,\n그 판단을 바탕으로 단일 역할 수행이 가능한지, 그리고 그 역할 내에서 독립적으로 의사결정을 내릴 수 있는지를 중심에 두는 것이 중요합니다."
        }
      ]
    },
    {
      "id": "253d3416-0518-806a-9ddb-f4fb4be353a9",
      "title": "지금 주목할 LLM 기술 흐름과 생성형 AI 적용 인사이트 (네이버클라우드 강지나 수석) (1)",
      "last_edited": "2025-08-18T08:00:00.000Z",
      "created": "2025-08-18T06:08:00.000Z",
      "url": "https://www.notion.so/LLM-AI-1-253d34160518806a9ddbf4fb4be353a9",
      "content": [
        {
          "type": "paragraph",
          "text": "LLM을 둘러싼 흐름은 지금 매우 빠르게 변화하고 있습니다. 특히, 세 가지 키워드가 큰 축을 이루고 있는데요 — 물리 세계로의 확장, Agentic AI, 그리고 상호 운영성을 중심으로 흐름과 시사하는 바를 짚어보겠습니다."
        },
        {
          "type": "heading_2",
          "text": "1. LLM into Physical world"
        },
        {
          "type": "paragraph",
          "text": "이제 LLM은 더 이상 디지털 안에만 머물지 않습니다. 모델을 넘어서 현실로 들어오고 있습니다."
        },
        {
          "type": "paragraph",
          "text": "OpenAI는 2026년 자체 AI 기기 출시를 예고했고, Google 역시 픽셀 폰과 스마트 글라스 등 Gemini 기반의 하드웨어 플랫폼을 준비 중입니다. 이건 단순히 LLM이 웹이나 앱에 탑재되는 수준이 아닙니다. LLM이 물리적인 하드웨어 생태계를 중심으로 재편되는 흐름이 본격화되고 있는 겁니다. 디지털에 국한됐던 AI가 이제는 우리의 일상 공간으로 들어오고 있는 것이죠."
        },
        {
          "type": "paragraph",
          "text": "기기, 센서, 현실 데이터와 결합되면서 LLM은 정보를 단순히 처리하는 도구가 아니라, 실시간으로 세상을 이해하고 반응하는 존재로 진화하고 있습니다. 이는 기술의 패러다임 자체가 전환되고 있다는 신호입니다."
        },
        {
          "type": "heading_2",
          "text": "2. Agentic AI의 부상"
        },
        {
          "type": "paragraph",
          "text": "두 번째 흐름은 Agentic AI입니다. 이 기술의 핵심은 바로 자율성입니다. 이제 LLM은 단순히 지시를 받아 답을 주는 것을 넘어서, 스스로 계획하고, 문제를 해결하며, 능동적으로 움직이는 AI로 발전하고 있습니다."
        },
        {
          "type": "image",
          "text": "가트너의 올해 10대 트랜드"
        },
        {
          "type": "paragraph",
          "text": "예를 들어, 웹을 검색하고, 자료를 요약하고, 글을 작성하고, 그 결과를 다시 검토하며 최종 결과를 도출하는 전 과정을 AI가 스스로 진행할 수 있어야 합니다. 네이버에서 최근 공개한 추론 모델 HyperCLOVA X THINK도 이런 Agentic AI의 중요한 예입니다. 자유롭게 언어적으로 상호작용하고, 상황에 맞게 대화를 이어가는 능력을 탑재하고 있으며, 오픈소스로 공개될 예정입니다."
        },
        {
          "type": "heading_3",
          "text": "가. Search techinque types"
        },
        {
          "type": "bulleted_list_item",
          "text": "Best-of-N : Agentic AI가 가장 최적의 방안 N개를 도출하고, 그 N개 중에 검증의 단계를 거쳐 가장 최적의 방안 1개를 선택하는 방식"
        },
        {
          "type": "bulleted_list_item",
          "text": "Beam Search : Agentic 모델이 최적의 방안을 찾기 위해서 여러 단계를 거치고, 각각의 단계별로 가작 적합한 후보 N개를 유지하면서 가장 마지막 단계를 통해 가장 적합한 방안 1개를 도출"
        },
        {
          "type": "bulleted_list_item",
          "text": "Lookahead Search : Beam Search와 유사하게 각각의 후보들에 대해 시뮬레이션을 진행함. 이 방안을 선택했을 때 예상되는 결과물을 통해 이 후보가 적합한지 아닌지를 판단을"
        },
        {
          "type": "heading_3",
          "text": "나. Agentic AI Use Case / Industry"
        },
        {
          "type": "numbered_list_item",
          "text": "Security\n: 애플리케이션의 잠재적인 취약점을 진단하고 이를 보완할 수 있는 코드를 생성하는데 사용됨"
        },
        {
          "type": "numbered_list_item",
          "text": "Supply chain & Inventory Management\n: 수요를 예측할 시는 현재의 영업 활동 데이터, 시즈널한 트랜드, 현재 회사 내부에서 진행되고 있는 다양한 프로모션, 경제적 지표 등 다양한 데이터를 결합하여 미래의 수요를 예측하게 되는데, 이 작업을 수행하고 적정 수준의 재고를 유지하는데 적극적으로 활용되고 있음"
        },
        {
          "type": "numbered_list_item",
          "text": "Customer Service & Support\n: 기존의 챗봇 같은 경우에는 규칙 기반이다 보니 예외 상황에서는 답변을 처리하지 못한다던가, 백엔드와의 연계가 어렵기 때문에 단편적인 질의 상황에 대해서만 처리가 가능했다면, 에이전틱 AI의 광범위한 질의 사항, 더 나아가 회사 내부의 백엔드와 연계가 되어 고객의 요청에 따라 주문을 취소한다던지, 상품의 반품을 처리하는 등 실질적인 사용자의 요청사항을 A to Z로 처리할 수 있음"
        },
        {
          "type": "heading_3",
          "text": "다. Agentic AI Use Case / Solution"
        },
        {
          "type": "numbered_list_item",
          "text": "Salesforcs\n에이전트가 잠재 고객의 이메일 및 활동 데이터를 분석하여 다음 단꼐를 제안하고, 영업 사원 대신 후속 이메일을 작성하여, 미팅 일정을 조율, 고객의 질문에 대한 답변을 CRM 시스템 내에서 찾아 자동으로 제공하거나, 관련 문서를 준비"
        },
        {
          "type": "numbered_list_item",
          "text": "Google\n광고주가 설정한 목표(예: 전환율 최대화, 특정 CPA 달성)에 따라 AI 에이전트가 실시간으로 입찰가를 조정, 이는 단순히 고정된 규칙이 아니라, 사용자 행동, 디바이스, 시간, 위치 등 수많은 신호를 종합적으로 분석하여 최적의 입착 전략을 자율적으로 실행"
        },
        {
          "type": "numbered_list_item",
          "text": "ServiceNow\n사용자가 IT 문제(예: 비밀번호 재설정, 소프트웨어 접근 권한 요청)를 제기하면, AI 에이전트가 요청을 분류하고, 관견 시스템(AD, HR 시스템 등)에 접속하여 필요한 정보를 조회하며, 자율적으로 문제를 해결"
        },
        {
          "type": "heading_3",
          "text": "라. Agentic AI Considerations"
        },
        {
          "type": "paragraph",
          "text": "에이전트를 잘 설계하기 위해서는 다음 다섯 가지 요소를 고민하셔야 합니다."
        },
        {
          "type": "numbered_list_item",
          "text": "명확한 범위 정의: 이 에이전트가 수행할 역할과 과제를 명확히 정의하세요."
        },
        {
          "type": "numbered_list_item",
          "text": "구체적인 계획: 어떤 검색 기법을 쓸지, 어떤 모델을 어떻게 조합할지 구체적으로 설계해야 합니다."
        },
        {
          "type": "numbered_list_item",
          "text": "메모리 구조: 단기 기억(현재 작업 중심)과 장기 기억(과거 학습된 정보)을 어떻게 설계할지도 핵심입니다."
        },
        {
          "type": "numbered_list_item",
          "text": "도구 및 데이터 통합: 외부 API나 도구와 얼마나 매끄럽게 연동되는지도 성능에 큰 영향을 줍니다."
        },
        {
          "type": "numbered_list_item",
          "text": "정확도 평가: 에이전트의 각 행동이 기대 수준에 도달했는지 지속적으로 측정하고 개선해야 합니다."
        },
        {
          "type": "heading_2",
          "text": "3. 상호 운영성 (Interoperability)의 중요성"
        },
        {
          "type": "paragraph",
          "text": "Agentic AI가 혼자 일하는 시대는 끝났습니다. 이제는 LLM이 외부 도구, 데이터, 시스템과 유기적으로 연동되는 구조가 필수입니다. 그 대표적인 예가 바로 MCP (Multi-Context Protocol)입니다. MCP는 다양한 데이터 소스나 툴과 LLM을 쉽게 연결해 주는 일종의 연결 프로토콜인데요. 기존에는 API 연동에서 발생하는 포맷 문제, 인터페이스 차이 등으로 통합이 어려웠다면, 이제는 MCP를 통해 훨씬 더 간결하고 유연한 연동이 가능해졌습니다."
        },
        {
          "type": "paragraph",
          "text": "Google도 최근 다양한 파트너사들과 함께 Agent-to-Agent 프로토콜을 공개했습니다. 각기 다른 전문 도메인의 AI들이 서로 통신하며 협업 기반으로 문제를 해결하는 시대가 열린 겁니다."
        },
        {
          "type": "heading_2",
          "text": "4. \"AI 에이전트를 잘 활용하려면 어떻게 해야 하나요?\""
        },
        {
          "type": "paragraph",
          "text": "한 참석자분께서 사전 질문으로 보내주신 내용입니다. 저는 세 가지로 정리해 말씀드리고 싶어요."
        },
        {
          "type": "paragraph",
          "text": "기대 수준과 목표 설정이 선행돼야 합니다."
        },
        {
          "type": "paragraph",
          "text": "단순히 ‘LLM을 써보자’가 아니라, \"이 에이전트를 왜 도입하는가?\", \"어떤 문제를 해결할 것인가?\"에 대한 명확한 정의가 있어야 합니다."
        },
        {
          "type": "paragraph",
          "text": "지속적인 평가가 필요합니다."
        },
        {
          "type": "paragraph",
          "text": "생성형 AI 생태계는 하루가 다르게 변합니다. 새로운 기술이나 프레임워크가 등장할 때마다 이를 적극적으로 실험해 보고, 우리 시스템에 어떤 영향을 줄 수 있을지 유연하게 검토하는 태도가 필요합니다."
        },
        {
          "type": "paragraph",
          "text": "애플리케이션 수준의 혁신에 집중해야 합니다."
        },
        {
          "type": "paragraph",
          "text": "단순히 좋은 모델을 연결하는 것이 아니라, AI가 제품과 서비스에서 어떤 실질적인 혁신을 이끌어낼 수 있을지 고민해야 합니다. 사용자 중심에서 문제를 바라보고, 그것을 해결하는 도구로서 AI를 활용할 수 있어야 해요."
        },
        {
          "type": "paragraph",
          "text": "이제는 단순한 모델 성능보다 어떻게 구성하고 연결하고 실현해 내는지가 훨씬 더 중요한 시점입니다. LLM은 이제 기술이 아니라 경험을 만들고 있습니다. AI와 함께 움직이는 시대, 여러분은 어떤 에이전트를 만들고 계신가요?"
        }
      ]
    },
    {
      "id": "253d3416-0518-80fd-afdc-d479b6ee0bfd",
      "title": "제목 없음",
      "last_edited": "",
      "created": "",
      "url": "",
      "content": []
    },
    {
      "id": "253d3416-0518-8044-b73f-e80ef7f2b95f",
      "title": "AI Agent 구현을 위한 MCP 활용 방안 (네이버클라우드 최장호 수석) (1)",
      "last_edited": "2025-08-18T05:16:00.000Z",
      "created": "2025-08-18T05:16:00.000Z",
      "url": "https://www.notion.so/AI-Agent-MCP-1-253d341605188044b73fe80ef7f2b95f",
      "content": [
        {
          "type": "paragraph",
          "text": "앞선 발표에서 소개하였듯, AI 에이전트를 실제 서비스에 적용하기 위해선 LLM이 다양한 툴과 연동되어야 합니다. 하지만 이 연동 과정이 생각보다 만만치 않죠. 저는 이번 세션에서 MCP가 왜 필요한지, 어떻게 구현되고 적용되는지 사례를 중심으로 공유드리겠습니다."
        },
        {
          "type": "heading_2",
          "text": "AI 에이전트는 어떻게 진화하고 있을까?"
        },
        {
          "type": "paragraph",
          "text": "초기 LLM은 단순 질문에 답하거나 문장을 생성하는 수준이었습니다. 그러나 학습된 시점까지의 데이터로 답변을 해주기 때문에, 내부 데이터 혹은 최신 데이터를 실시간으로 반영할 수 있도록 RAG(Retrieval-Augmented Generation) 방식이 등장했고, 지금은 LLM이 외부 툴과 연동되는 에이전트 형태로 발전하고 있습니다."
        },
        {
          "type": "paragraph",
          "text": "에이전트는 사용자의 요청을 받고, 이를 처리하기 위해 어떤 툴을 써야 할지 판단하고, 툴을 호출하고 실행한 뒤, 결과를 바탕으로 답변을 구성하는 순서. 'Observe(관찰) → Plan(계획) → Act(실행)' 구조로 움직이게 되는데요. 이때 핵심은 어떤 툴을 얼마나 잘 연결할 수 있느냐, 그리고 툴 호출을 잘 수행할 수 있는 LLM을 쓰느냐에 달려 있어요. 그리고 MCP는 이 부분에서 도움을 줄 수 있는 것이죠."
        },
        {
          "type": "image",
          "text": "에이전트의 작동 구조 (출처: https://www.bcg.com/capabilities/artificial-intelligence/ai-agents)"
        },
        {
          "type": "heading_2",
          "text": "MCP가 등장한 이유"
        },
        {
          "type": "paragraph",
          "text": "문제는 툴을 연결하는 과정이 매우 번거롭다는 점입니다. 예를 들어 LLM 기반 애플리케이션(LangChain, ChatGPT, Claude 등)에 메일, Notion, GitHub, Slack 같은 도구를 연동하려면 각각의 SDK나 API에 맞춰 따로 개발해야 하죠."
        },
        {
          "type": "image",
          "text": "MCP의 등장 배경: 여러 도구를 연결하는 과정의 번거로움"
        },
        {
          "type": "paragraph",
          "text": "이런 문제를 해결하기 위해 등장한 것이 바로 MCP(Multi-Tool Connection Protocol)입니다. 엔트로픽(Anthropic)에서 제안한 방식인데, 요약하자면 \"LLM이 외부 툴과 통신할 수 있도록 표준화된 프로토콜\"이라고 할 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "LLM(예: HyperCLOVA X, Claude, GPT 등)은 MCP 클라이언트, 외부 툴(예: Notion, Gmail, GitHub 등)은 MCP 서버, 둘 사이를 표준화된 방식(JSON-RPC 기반)으로 통신하게 합니다. 이 프로토콜 덕분에 여러 툴을 붙일 때 매번 복잡한 로직을 새로 짤 필요 없이 간단히 표준만 맞춰주면 바로 쓸 수 있게 되는 거죠."
        },
        {
          "type": "image",
          "text": "MCP: LLM이 외부 데이터 및 도구와 상호작용할 수 있도록 설계된 프로토콜 (이미지 출처)"
        },
        {
          "type": "heading_2",
          "text": "MCP, 이렇게 쓸 수 있어요."
        },
        {
          "type": "paragraph",
          "text": "저희도 MCP를 기반으로 다양한 프로젝트를 진행하고 있습니다. 제가 직접 해본 예로, 긴 유튜브 영상을 요약해 노션에 자동 정리하는 워크플로우를 MCP로 만들었습니다. 자막 추출, 댓글 요약, 캡처 생성, 노션 업로드까지 한 줄 지시로 Claude가 다 처리해 주니 정말 AI 에이전트 같더라고요."
        },
        {
          "type": "paragraph",
          "text": "코드 관리에도 MCP는 굉장히 유용하게 쓰입니다. GitHub 이슈를 자동으로 읽고, 관련 코드를 수정하고, 커밋까지 해주는 자동화도 가능합니다. 실제로 Cursor AI에서 이런 기능을 통해 이슈를 해결하는 시나리오를 구성해 봤고요."
        },
        {
          "type": "heading_2",
          "text": "반복 없이 챗봇 확장하기: MCP로 유연하게 구성하는 방법"
        },
        {
          "type": "paragraph",
          "text": "고객사에서 자주 요청하는 기능 중 하나가 '챗봇에 실시간 웹 검색이나 내부 문서 검색 기능을 붙이는 것'입니다. 하지만 이를 구현하려면 매번 새로운 API를 붙이고 복잡한 로직을 짜야 해서 부담이 크죠. 이런 상황에서 MCP를 사용하면 도구 추가나 교체가 표준화된 방식으로 가능해 훨씬 유연하게 구성할 수 있습니다."
        },
        {
          "type": "paragraph",
          "text": "예를 들어 LangGraph로 에이전트의 흐름을 만들고, 내부에서 MCP Client가 동작해 외부 MCP Server(웹 검색, 문서 검색 등)와 통신하는 구조를 생각해 볼 수 있습니다."
        },
        {
          "type": "image",
          "text": "MCP Client와 MCP Server간 통신 구조"
        },
        {
          "type": "paragraph",
          "text": "이 구조는 네이버 클라우드 플랫폼 환경에서도 쉽게 구성할 수 있어요. 예를 들어, LLM은 네이버클라우드의 HyperCLOVA X를 사용하고, 벡터 DB는 NAVER Search DB 혹은 Pinecone 등을 활용합니다. 서버는 Docker(도커)로 로컬에 구성하면 보안상 더 안전하고요."
        },
        {
          "type": "paragraph",
          "text": "실제로 오래된 문서 정보를 최신 웹 데이터와 비교해 더 정확한 답을 자동으로 판단하는 AI 에이전트를 구현해 봤습니다. “예결위 위원이 몇 명이야?”라는 질문에 문서와 웹 정보를 비교해 최신 값을 반환하는 방식인데요. 이런 구조 덕분에 고객사는 복잡한 정보 판단까지 자동화할 수 있습니다."
        },
        {
          "type": "image",
          "text": "네이버 클라우드 플랫폼을 활용한 MCP 구성"
        },
        {
          "type": "heading_2",
          "text": "MCP, 선택이 아닌 필수"
        },
        {
          "type": "paragraph",
          "text": "결국 에이전트는 ‘연결’이 핵심입니다. MCP는 툴을 만드는 개발자와, 그것을 활용할 수 있는 LLM 사이의 연결 고리를 제공합니다. 앞으로 Agentic AI가 더 발전하려면, 다양한 툴과의 연동이 점점 더 중요해질 겁니다. MCP 같은 표준이 자리 잡을수록 개발자는 더 빠르게 툴을 만들고, LLM은 더 강력한 에이전트로 진화할 수 있겠죠."
        },
        {
          "type": "paragraph",
          "text": "여기 계신 여러분도 AI 프로젝트를 하시면서 반복적인 툴 연결 작업이 부담스럽다고 느끼셨다면, MCP 도입을 꼭 고려해 보시길 추천드립니다."
        }
      ]
    }
  ],
  "collection_timestamp": "2025-08-18T18:01:26.168170",
  "source": "real_api"
}